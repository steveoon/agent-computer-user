# 配置版本管理说明

## 概述

配置系统现在支持智能的版本管理，能够区分"版本升级"和"数据修复"两种不同的操作。

## 版本管理策略

### 1. 版本升级 (Version Upgrade)

- **触发条件**：导入的配置版本号低于当前系统版本
- **操作内容**：
  - 更新版本号到最新版本
  - 补全新版本所需的所有字段
  - 添加 `upgradedAt` 时间戳
- **示例**：从 v1.0.0 升级到 v1.2.0

### 2. 数据修复 (Data Repair)

- **触发条件**：导入的配置版本号已是最新，但某些字段缺失
- **操作内容**：
  - **保持版本号不变**
  - 仅补全缺失的必需字段
  - 添加 `repairedAt` 时间戳（而非 `upgradedAt`）
- **示例**：v1.2.0 配置缺少部分品牌模板字段

## 技术实现

### upgradeConfigData 函数签名

```typescript
async function upgradeConfigData(
  existingConfig: AppConfigData,
  saveToStorage = true,
  forceRepair = false // 新增参数
): Promise<AppConfigData>;
```

### 参数说明

- `existingConfig`: 需要升级或修复的配置数据
- `saveToStorage`: 是否保存到本地存储（导入时设为 false）
- `forceRepair`: 强制执行修复而非升级（当版本号已是最新时自动设置）

## 元数据字段

配置的 `metadata` 对象包含以下时间戳字段：

```typescript
metadata: {
  version: string;           // 配置版本号
  lastUpdated: string;       // 最后更新时间
  migratedAt?: string;       // 从硬编码数据迁移的时间
  upgradedAt?: string;       // 版本升级的时间
  repairedAt?: string;       // 数据修复的时间（新增）
}
```

## 使用场景

### 场景1：导入旧版本配置

```
导入 v1.0.0 配置 → 检测版本差异 → 执行版本升级 → 更新到 v1.2.0
```

### 场景2：导入最新版本但不完整的配置

```
导入 v1.2.0 配置（缺少字段）→ 检测版本相同 → 执行数据修复 → 版本号保持 v1.2.0
```

### 场景3：导出后再导入

```
导出配置（可能缺少字段）→ 导入同一配置 → 仅修复缺失字段 → 避免版本号循环更新
```

## 优势

1. **准确的版本追踪**：版本号真实反映数据结构的演进
2. **避免循环升级**：多次导入导出不会反复更新版本号
3. **清晰的审计记录**：通过不同的时间戳字段区分操作类型
4. **更好的兼容性**：自动修复不完整的数据，提高系统容错性

## 测试覆盖

系统包含完整的测试用例：

- ✅ 旧版本配置升级测试
- ✅ 最新版本配置修复测试
- ✅ 版本号保持不变验证
- ✅ 时间戳字段正确性验证

## 注意事项

1. 版本号格式遵循语义化版本规范（如 1.2.0）
2. 数据修复不会触发版本号变更，避免误导用户
3. 所有操作都有详细的日志输出，便于调试和审计
